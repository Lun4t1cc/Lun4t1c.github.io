- malloc 申请被放入 Tcachebins 中的 chunk 后，chunk 的 fd 指针不会被清空

- tcache_put 和 tcache_get 函数的源码

  ```c
  static void
  tcache_put (mchunkptr chunk, size_t tc_idx)
  {
    tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
    assert (tc_idx < TCACHE_MAX_BINS);
    e->next = tcache->entries[tc_idx];
    tcache->entries[tc_idx] = e;
    ++(tcache->counts[tc_idx]);
  }
  
  static void *
  tcache_get (size_t tc_idx)
  {
    tcache_entry *e = tcache->entries[tc_idx];
    assert (tc_idx < TCACHE_MAX_BINS);
    assert (tcache->entries[tc_idx] > 0);
    tcache->entries[tc_idx] = e->next;
    --(tcache->counts[tc_idx]);
    return (void *) e;
  }
  ```

- tcache_perthread_struct 最先分配，它保存在堆段底部

- tcache_entry 和 tcache_perthread_struct 结构体

  ```c
  /* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */
  typedef struct tcache_entry
  {
    struct tcache_entry *next;
  } tcache_entry;
  
  /* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct").  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */
  typedef struct tcache_perthread_struct
  {
    char counts[TCACHE_MAX_BINS];
    tcache_entry *entries[TCACHE_MAX_BINS];
  } tcache_perthread_struct;
  
  static __thread tcache_perthread_struct *tcache = NULL;
  ```

- 在 tcache_perthread_struct 结构体中，entries 数组中保存的结构体的 size 随 idx 的增加而增加
- malloc 申请被放入 Tcachebins 中的 chunk 后，chunk 的 fd 指针不会被清空

- tcache_put 和 tcache_get 函数的源码

  ```c
  static void
  tcache_put (mchunkptr chunk, size_t tc_idx)
  {
    tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
    assert (tc_idx < TCACHE_MAX_BINS);
    e->next = tcache->entries[tc_idx];
    tcache->entries[tc_idx] = e;
    ++(tcache->counts[tc_idx]);
  }
  
  static void *
  tcache_get (size_t tc_idx)
  {
    tcache_entry *e = tcache->entries[tc_idx];
    assert (tc_idx < TCACHE_MAX_BINS);
    assert (tcache->entries[tc_idx] > 0);
    tcache->entries[tc_idx] = e->next;
    --(tcache->counts[tc_idx]);
    return (void *) e;
  }
  ```

- tcache_perthread_struct 最先分配，它保存在堆段底部

- tcache_entry 和 tcache_perthread_struct 结构体

  ```c
  /* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */
  typedef struct tcache_entry
  {
    struct tcache_entry *next;
  } tcache_entry;
  
  /* There is one of these for each thread, which contains the per-thread cache (hence "tcache_perthread_struct").  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */
  typedef struct tcache_perthread_struct
  {
    char counts[TCACHE_MAX_BINS];
    tcache_entry *entries[TCACHE_MAX_BINS];
  } tcache_perthread_struct;
  
  static __thread tcache_perthread_struct *tcache = NULL;
  ```

- 在 tcache_perthread_struct 结构体中，entries 数组中保存的结构体的 size 随 idx 的增加而增加

- tcache_entry 通过单链表连接 chunk 结构体

- tcache_entry 中的 next 指针指向下一个相同大小的 chunk 的 user data 

- tcache 在被 free 后不会清除 inuse 标志，不会被合并

- 每个不同 size 的 tcache 链表默认最多能存放 7 个 chunk

- 当 tcache 存满后，被 free 的 chunk 会被放入 Fastbins 或 Unsorted bin

- Tcachebins 遵循 FILO 原则

- 申请一个 chunk 时，如果该 chunks 的 size 在 tcache 的范围内，则首先会从 Tcachebins 中查找是否有符合条件的 chunk

- 申请一个 chunk 时，如果该 chunks 的 size 在 tcache 的范围内，且对应的 Tcachebins 为空，则会从其他 bins 中查找是否有满足条件的 chunk